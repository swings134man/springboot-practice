### Log Tracer Package Info

1. Spring Boot 를 통해. Log 추적기를 만든다.
    - 개발자가 일일히 모든 Class 내부에 log를 넣어도 되지만, Log추적기를 사용하면,전역에서 확인가능.
------------------------------------------------------------------------------------------------
* 요구사항
    1. 모든 Public 메서드의 '호출, 응답' 정보를 log 로 출력.
    2. 어플리케이션의 흐름 변경 X
        -> Log가 생성된다고 해서 비지니스 로직 동작에 영향을 주면 안된다.
    3. 메서드 호출에 걸린 시간
    4. 정상 흐름, 예외 흐름 구분
        -> 예외 발생시, 예외 정보 출력.
    5. 메서드 호출 depth(깊이) 표현
    6. HTTP 요청 구분.
        -> HTTP 요청 단위로 특정 ID 를 남겨서 어떤 HTTP 요청에서 시작된건지, 명확하게 구분하기 위함.
        -> 트랜잭션 ID(DB 트랜잭션 X), 여기서는 하나의 HTTP 요청이 시작-끝 까지를 하나의 '트랜잭션'이라고 함.

------------------------------------------------------------------------------------------------
* 패키지
- V0 부터 (가장 기본) 부터 시작하여 -> v1, v2 로 기능 추가 예정.

1. trace 패키지
    -> log 추적기를 위한 기반 데이터 파일 -> TraceId, TraceStatus -> boot패키지

------------------------------------------------------------------------------------------------

2. v1 패키지
    -> Transaction Id 가 일정하지 않음.
    -> Level(depth) 표시 되지 않음. -> Level 기능 존재X -> level=0
    -> log 를 남기기 위해 code 가 생각보다 복잡하다. -> 추후 리팩토링.

    - TODO: 메서드 호출 깊이 표현, HTTP 단위로 Transaction ID 일치, Loging code Refactoring
        -> 동기화 시키려면, service에서 로그를 남길때 controller에서 어떤 'depth(level), 트랜잭션ID'를 사용했는지 알아야한다.
        -> 즉, 트랜잭션ID, level 이 필요함.

------------------------------------------------------------------------------------------------

3. v2 패키지

    - FirstTraceV2.class 를 통해, method depth 기능을 정의 -> method: beginSync();
    - 요구사항 만족.

4. 잔류 문제
    - 파라미터를 계속 넘겨야 하는것.
    -

------------------------------------------------------------------------------------------------

5. v3 패키지 - 최종

    - 파라미터를 넘겨야 하는 방식 -> 참조를 통해 traceId, level 정보 확인.
        - 컨트롤러, 서비스, 레포지토리 메서드상 parameter 사용X (원래는 : 이전 log정보를 파악하기 위해, 파라미터로 TraceId를 넘겼음.)

6. v3 패키지 - 동시성문제 해결

    - 문제상황
        -> 어플리케이션의 모든 서비스 계층이 같은 FiledLogTrace를 사용하므로,
        -> 하나의 객체(싱글톤 Bean)에 Client들의 모든 요청에 대한 trace 정보가 저장된다.
        -> 즉 -> "FiledLogTracer.traceIdHolder 필드를 여러 Thread가 동시 접근" 하여 발생하는 문제.
        -> 접속을 동시하여, 동시 요청시, 각 트랜잭션들이 엉켜서 정상적인 로그 출력 불가능.

        ** 동시성문제는 : 인스턴스의 필드(주로 싱글톤), 또는 Static 같은 공용 필드에 접근할떄 발생.
        *** 또한 읽기만 할때는 발생 X, 값을 변경할때 발생.

    - 해결 - Thread Local
        -> Thread Local은 해당 Thread만 사용할 수 있는 특별한 저장.
        -> 여러 Thread가 '같은 저장소'를 사용하더라도, 저장소가 thread를 구분하여, 각 thread 저장소에 접근.
        -> 또한 사용 후 필수적으로 remove() 해줘야한다.

****. 정리

    1.

